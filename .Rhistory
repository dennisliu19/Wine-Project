parName1 = paste0("theta[",diffIdVec[t1Idx],"]")
parName2 = paste0("theta[",diffIdVec[t2Idx],"]")
summaryInfo = rbind( summaryInfo ,
summarizePost( mcmcMat[,parName1]-mcmcMat[,parName2] ,
compVal=compValDiff , ROPE=ropeDiff ) )
rowIdx = rowIdx+1
rownames(summaryInfo)[rowIdx] = paste0(parName1,"-",parName2)
}
}
}
# save:
if ( !is.null(saveName) ) {
write.csv( summaryInfo , file=paste(saveName,"SummaryInfo.csv",sep="") )
}
show( summaryInfo )
return( summaryInfo )
}
#===============================================================================
plotMCMC = function( codaSamples , data , sName="s" , yName="y" ,
compVal=0.5 , rope=NULL ,
diffIdVec=NULL , compValDiff=0.0 , ropeDiff=NULL ,
saveName=NULL , saveType="jpg" ) {
#-----------------------------------------------------------------------------
# N.B.: This function expects the data to be a data frame,
# with one component named y being a vector of integer 0,1 values,
# and one component named s being a factor of subject identifiers.
y = data[,yName]
s = as.numeric(data[,sName]) # ensures consecutive integer levels
# Now plot the posterior:
mcmcMat = as.matrix(codaSamples,chains=TRUE)
chainLength = NROW( mcmcMat )
# Plot omega, kappa:
openGraph(width=3.5*2,height=3.0)
par( mfrow=c(1,2) )
par( mar=c(3.5,3,1,1) , mgp=c(2.0,0.7,0) )
postInfo = plotPost( mcmcMat[,"kappa"] , compVal=NULL , ROPE=NULL ,
xlab=bquote(kappa) , main="" ,
xlim=c( min(mcmcMat[,"kappa"]),
quantile(mcmcMat[,"kappa"],probs=c(0.990)) ) )
postInfo = plotPost( mcmcMat[,"omega"] , compVal=compVal , ROPE=rope ,
xlab=bquote(omega) , main="Group Mode" ,
xlim=quantile(mcmcMat[,"omega"],probs=c(0.005,0.995)) )
if ( !is.null(saveName) ) {
saveGraph( file=paste(saveName,"PostOmega",sep=""), type=saveType)
}
# Plot individual theta's and differences:
if ( !is.null(diffIdVec) ) {
Nidx = length(diffIdVec)
openGraph(width=2.5*Nidx,height=2.0*Nidx)
par( mfrow=c(Nidx,Nidx) )
for ( t1Idx in 1:Nidx ) {
for ( t2Idx in 1:Nidx ) {
parName1 = paste0("theta[",diffIdVec[t1Idx],"]")
parName2 = paste0("theta[",diffIdVec[t2Idx],"]")
if ( t1Idx > t2Idx) {
# plot.new() # empty plot, advance to next
par( mar=c(3.5,3.5,1,1) , mgp=c(2.0,0.7,0) , pty="s" )
nToPlot = 700
ptIdx = round(seq(1,chainLength,length=nToPlot))
plot ( mcmcMat[ptIdx,parName2] , mcmcMat[ptIdx,parName1] , cex.lab=1.75 ,
xlab=parName2 , ylab=parName1 , col="skyblue" )
abline(0,1,lty="dotted")
} else if ( t1Idx == t2Idx ) {
par( mar=c(3.5,1,1,1) , mgp=c(2.0,0.7,0) , pty="m" )
postInfo = plotPost( mcmcMat[,parName1] , cex.lab = 1.75 ,
compVal=compVal , ROPE=rope , cex.main=1.5 ,
xlab=parName1 , main="" )
includeRows = ( s == diffIdVec[t1Idx] ) # rows of this subject in data
dataPropor = sum(y[includeRows])/sum(includeRows)
points( dataPropor , 0 , pch="+" , col="red" , cex=3 )
} else if ( t1Idx < t2Idx ) {
par( mar=c(3.5,1,1,1) , mgp=c(2.0,0.7,0) , pty="m" )
postInfo = plotPost( mcmcMat[,parName1]-mcmcMat[,parName2] ,
compVal=compValDiff , ROPE=ropeDiff , cex.main=1.5 ,
xlab=paste0(parName1,"-",parName2) , main="" ,
cex.lab=1.75 )
includeRows1 = ( s == diffIdVec[t1Idx] ) # rows of this subject in data
dataPropor1 = sum(y[includeRows1])/sum(includeRows1)
includeRows2 = ( s == diffIdVec[t2Idx] ) # rows of this subject in data
dataPropor2 = sum(y[includeRows2])/sum(includeRows2)
points( dataPropor1-dataPropor2 , 0 , pch="+" , col="red" , cex=3 )
}
}
}
}
if ( !is.null(saveName) ) {
saveGraph( file=paste(saveName,"PostTheta",sep=""), type=saveType)
}
}
#===============================================================================
# Example for Jags-Ydich-XnomSsubj-MbinomBetaOmegaKappa.R
#-------------------------------------------------------------------------------
# Optional generic preliminaries:
#graphics.off() # This closes all of R's graphics windows.
#rm(list=ls())  # Careful! This clears all of R's memory!
#-------------------------------------------------------------------------------
# Load The data
myData = read.csv("TherapeuticTouchData.csv")
# N.B.: The functions below expect the data to be a data frame,
# with one component named y being a vector of integer 0,1 values,
# and one component named s being a factor of subject identifiers.
#-------------------------------------------------------------------------------
# Load the relevant model into R's working memory:
#source("Jags-Ydich-XnomSsubj-MbinomBetaOmegaKappa.R")
#-------------------------------------------------------------------------------
# Optional: Specify filename root and graphical format for saving output.
# Otherwise specify as NULL or leave saveName and saveType arguments
# out of function calls.
fileNameRoot = "Jags-Ydich-XnomSsubj-MbinomBetaOmegaKappa-"
graphFileType = "eps"
#-------------------------------------------------------------------------------
# Generate the MCMC chain:
startTime = proc.time()
mcmcCoda = genMCMC( data=myData , sName="s" , yName="y" ,
numSavedSteps=20000 , saveName=fileNameRoot ,
thinSteps=10 )
stopTime = proc.time()
show( stopTime-startTime )
#-------------------------------------------------------------------------------
# Display diagnostics of chain, for specified parameters:
#parameterNames = varnames(mcmcCoda) # get all parameter names for reference
#for ( parName in parameterNames[c(1:3,length(parameterNames))] ) {
#  diagMCMC( codaObject=mcmcCoda , parName=parName ,
#                saveName=fileNameRoot , saveType=graphFileType )
#}
diagMCMC( codaObject=mcmcCoda , parName="omega" ,
saveName=fileNameRoot , saveType=graphFileType )
#-------------------------------------------------------------------------------
# Get summary statistics of chain:
#summaryInfo = smryMCMC( mcmcCoda , compVal=0.5 ,
#                        diffIdVec=c(1,14,28), compValDiff=0.0,
#                        saveName=fileNameRoot )
# Display posterior information:
#plotMCMC( mcmcCoda , data=myData , sName="s" , yName="y" ,
#          compVal=0.5 , #rope=c(0.45,0.55) ,
#          diffIdVec=c(1,14,28), compValDiff=0.0, #ropeDiff = c(-0.05,0.05) ,
#          saveName=fileNameRoot , saveType=graphFileType )
#-------------------------------------------------------------------------------
# Example for Jags-Ybinom-XnomSsubjCcat-MbinomBetaOmegaKappa.R
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
# Read the data
myData = read.csv("SmallSurgeonData.csv")
#-------------------------------------------------------------------------------
# Load the relevant model into R's working memory:
#-------------------------------------------------------------------------------
# Optional: Specify filename root and graphical format for saving output.
# Otherwise specify as NULL or leave saveName and saveType arguments
# out of function calls.
fileNameRoot = "SmallSurgeon-POST-"
graphFileType = "eps"
#-------------------------------------------------------------------------------
# Generate the MCMC chain:
startTime = proc.time()
mcmcCoda = genMCMC( data=myData ,
zName="Fatalities", NName="Surgeries", sName="Surgeon", cName="Hospital",
numSavedSteps=11000 , saveName=fileNameRoot ,
thinSteps=20 )
# Jags-Ydich-XnomSsubj-MbinomBetaOmegaKappa.R
# Accompanies the book:
#   Kruschke, J. K. (2015). Doing Bayesian Data Analysis, Second Edition:
#   A Tutorial with R, JAGS, and Stan. Academic Press / Elsevier.
source("~/Desktop/MAT-444/DBDA2E-utilities.R")
#===============================================================================
genMCMC = function( data , sName="s" , yName="y" ,
numSavedSteps=50000 , saveName=NULL , thinSteps=1 ,
runjagsMethod=runjagsMethodDefault ,
nChains=nChainsDefault ) {
require(rjags)
require(runjags)
#-----------------------------------------------------------------------------
# THE DATA.
# N.B.: This function expects the data to be a data frame,
# with one component named y being a vector of integer 0,1 values,
# and one component named s being a factor of subject identifiers.
y = data[,yName]
s = as.numeric(data[,sName]) # ensures consecutive integer levels
# Do some checking that data make sense:
if ( any( y!=0 & y!=1 ) ) { stop("All y values must be 0 or 1.") }
z = aggregate( y , by=list(s) , FUN=sum )$x
N = aggregate( rep(1,length(y)) , by=list(s) , FUN=sum )$x
Nsubj = length(unique(s))
# Specify the data in a list, for later shipment to JAGS:
dataList = list(
z = z ,
N = N ,
Nsubj = Nsubj
)
#-----------------------------------------------------------------------------
# THE MODEL.
modelString = "
model {
for ( s in 1:Nsubj ) {
z[s] ~ dbin( theta[s] , N[s] )
theta[s] ~ dbeta( omega*(kappa-2)+1 , (1-omega)*(kappa-2)+1 )
}
omega ~ dbeta( 1 , 1 )
kappa <- kappaMinusTwo + 2
#kappaMinusTwo ~ dgamma( 0.01 , 0.01 )  # mean=1 , sd=10 (generic vague)
kappaMinusTwo ~ dgamma( 1.105125 , 0.1051249 )  # mode=1 , sd=10
}
" # close quote for modelString
writeLines( modelString , con="TEMPmodel.txt" )
#-----------------------------------------------------------------------------
# INTIALIZE THE CHAINS.
# Initial values of MCMC chains based on data:
initsList = function() {
thetaInit = rep(0,Nsubj)
for ( sIdx in 1:Nsubj ) { # for each subject
includeRows = ( s == sIdx ) # identify rows of this subject
yThisSubj = y[includeRows]  # extract data of this subject
resampledY = sample( yThisSubj , replace=TRUE ) # resample
thetaInit[sIdx] = sum(resampledY)/length(resampledY)
}
thetaInit = 0.001+0.998*thetaInit # keep away from 0,1
meanThetaInit = mean( thetaInit )
kappaInit = 100 # lazy, start high and let burn-in find better value
return( list( theta=thetaInit , omega=meanThetaInit ,
kappaMinusTwo=kappaInit-2 ) )
}
#-----------------------------------------------------------------------------
# RUN THE CHAINS
parameters = c( "theta","omega","kappa") # The parameters to be monitored
adaptSteps = 500             # Number of steps to adapt the samplers
burnInSteps = 500            # Number of steps to burn-in the chains
useRunjags = TRUE
if ( useRunjags ) {
runJagsOut <- run.jags( method=runjagsMethod ,
model="TEMPmodel.txt" ,
monitor=parameters ,
data=dataList ,
inits=initsList ,
n.chains=nChains ,
adapt=adaptSteps ,
burnin=burnInSteps ,
sample=ceiling(numSavedSteps/nChains) ,
thin=thinSteps ,
summarise=FALSE ,
plots=FALSE )
codaSamples = as.mcmc.list( runJagsOut )
} else {
# Create, initialize, and adapt the model:
jagsModel = jags.model( "TEMPmodel.txt" , data=dataList , inits=initsList ,
n.chains=nChains , n.adapt=adaptSteps )
# Burn-in:
cat( "Burning in the MCMC chain...\n" )
update( jagsModel , n.iter=burnInSteps )
# The saved MCMC chain:
cat( "Sampling final MCMC chain...\n" )
codaSamples = coda.samples( jagsModel , variable.names=parameters ,
n.iter=ceiling(numSavedSteps*thinSteps/nChains),
thin=thinSteps )
}
# resulting codaSamples object has these indices:
#   codaSamples[[ chainIdx ]][ stepIdx , paramIdx ]
if ( !is.null(saveName) ) {
save( codaSamples , file=paste(saveName,"Mcmc.Rdata",sep="") )
}
return( codaSamples )
} # end function
#===============================================================================
smryMCMC = function(  codaSamples , compVal=0.5 , rope=NULL ,
diffIdVec=NULL , compValDiff=0.0 , ropeDiff=NULL ,
saveName=NULL ) {
mcmcMat = as.matrix(codaSamples,chains=TRUE)
Ntheta = length(grep("theta",colnames(mcmcMat)))
summaryInfo = NULL
rowIdx = 0
# overall omega:
summaryInfo = rbind( summaryInfo ,
summarizePost( mcmcMat[,"omega"] ,
compVal=compVal , ROPE=rope ) )
rowIdx = rowIdx+1
rownames(summaryInfo)[rowIdx] = "omega"
# kappa:
summaryInfo = rbind( summaryInfo ,
summarizePost( mcmcMat[,"kappa"] ,
compVal=NULL , ROPE=NULL ) )
rowIdx = rowIdx+1
rownames(summaryInfo)[rowIdx] = "kappa"
# individual theta's:
for ( tIdx in 1:Ntheta ) {
parName = paste0("theta[",tIdx,"]")
summaryInfo = rbind( summaryInfo ,
summarizePost( mcmcMat[,parName] , compVal=compVal , ROPE=rope ) )
rowIdx = rowIdx+1
rownames(summaryInfo)[rowIdx] = parName
}
# differences of individual theta's:
if ( !is.null(diffIdVec) ) {
Nidx = length(diffIdVec)
for ( t1Idx in 1:(Nidx-1) ) {
for ( t2Idx in (t1Idx+1):Nidx ) {
parName1 = paste0("theta[",diffIdVec[t1Idx],"]")
parName2 = paste0("theta[",diffIdVec[t2Idx],"]")
summaryInfo = rbind( summaryInfo ,
summarizePost( mcmcMat[,parName1]-mcmcMat[,parName2] ,
compVal=compValDiff , ROPE=ropeDiff ) )
rowIdx = rowIdx+1
rownames(summaryInfo)[rowIdx] = paste0(parName1,"-",parName2)
}
}
}
# save:
if ( !is.null(saveName) ) {
write.csv( summaryInfo , file=paste(saveName,"SummaryInfo.csv",sep="") )
}
show( summaryInfo )
return( summaryInfo )
}
#===============================================================================
plotMCMC = function( codaSamples , data , sName="s" , yName="y" ,
compVal=0.5 , rope=NULL ,
diffIdVec=NULL , compValDiff=0.0 , ropeDiff=NULL ,
saveName=NULL , saveType="jpg" ) {
#-----------------------------------------------------------------------------
# N.B.: This function expects the data to be a data frame,
# with one component named y being a vector of integer 0,1 values,
# and one component named s being a factor of subject identifiers.
y = data[,yName]
s = as.numeric(data[,sName]) # ensures consecutive integer levels
# Now plot the posterior:
mcmcMat = as.matrix(codaSamples,chains=TRUE)
chainLength = NROW( mcmcMat )
# Plot omega, kappa:
openGraph(width=3.5*2,height=3.0)
par( mfrow=c(1,2) )
par( mar=c(3.5,3,1,1) , mgp=c(2.0,0.7,0) )
postInfo = plotPost( mcmcMat[,"kappa"] , compVal=NULL , ROPE=NULL ,
xlab=bquote(kappa) , main="" ,
xlim=c( min(mcmcMat[,"kappa"]),
quantile(mcmcMat[,"kappa"],probs=c(0.990)) ) )
postInfo = plotPost( mcmcMat[,"omega"] , compVal=compVal , ROPE=rope ,
xlab=bquote(omega) , main="Group Mode" ,
xlim=quantile(mcmcMat[,"omega"],probs=c(0.005,0.995)) )
if ( !is.null(saveName) ) {
saveGraph( file=paste(saveName,"PostOmega",sep=""), type=saveType)
}
# Plot individual theta's and differences:
if ( !is.null(diffIdVec) ) {
Nidx = length(diffIdVec)
openGraph(width=2.5*Nidx,height=2.0*Nidx)
par( mfrow=c(Nidx,Nidx) )
for ( t1Idx in 1:Nidx ) {
for ( t2Idx in 1:Nidx ) {
parName1 = paste0("theta[",diffIdVec[t1Idx],"]")
parName2 = paste0("theta[",diffIdVec[t2Idx],"]")
if ( t1Idx > t2Idx) {
# plot.new() # empty plot, advance to next
par( mar=c(3.5,3.5,1,1) , mgp=c(2.0,0.7,0) , pty="s" )
nToPlot = 700
ptIdx = round(seq(1,chainLength,length=nToPlot))
plot ( mcmcMat[ptIdx,parName2] , mcmcMat[ptIdx,parName1] , cex.lab=1.75 ,
xlab=parName2 , ylab=parName1 , col="skyblue" )
abline(0,1,lty="dotted")
} else if ( t1Idx == t2Idx ) {
par( mar=c(3.5,1,1,1) , mgp=c(2.0,0.7,0) , pty="m" )
postInfo = plotPost( mcmcMat[,parName1] , cex.lab = 1.75 ,
compVal=compVal , ROPE=rope , cex.main=1.5 ,
xlab=parName1 , main="" )
includeRows = ( s == diffIdVec[t1Idx] ) # rows of this subject in data
dataPropor = sum(y[includeRows])/sum(includeRows)
points( dataPropor , 0 , pch="+" , col="red" , cex=3 )
} else if ( t1Idx < t2Idx ) {
par( mar=c(3.5,1,1,1) , mgp=c(2.0,0.7,0) , pty="m" )
postInfo = plotPost( mcmcMat[,parName1]-mcmcMat[,parName2] ,
compVal=compValDiff , ROPE=ropeDiff , cex.main=1.5 ,
xlab=paste0(parName1,"-",parName2) , main="" ,
cex.lab=1.75 )
includeRows1 = ( s == diffIdVec[t1Idx] ) # rows of this subject in data
dataPropor1 = sum(y[includeRows1])/sum(includeRows1)
includeRows2 = ( s == diffIdVec[t2Idx] ) # rows of this subject in data
dataPropor2 = sum(y[includeRows2])/sum(includeRows2)
points( dataPropor1-dataPropor2 , 0 , pch="+" , col="red" , cex=3 )
}
}
}
}
if ( !is.null(saveName) ) {
saveGraph( file=paste(saveName,"PostTheta",sep=""), type=saveType)
}
}
#===============================================================================
# Example for Jags-Ybinom-XnomSsubjCcat-MbinomBetaOmegaKappa.R
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
# Read the data
myData = read.csv("SmallSurgeonData.csv")
#-------------------------------------------------------------------------------
# Load the relevant model into R's working memory:
#-------------------------------------------------------------------------------
# Optional: Specify filename root and graphical format for saving output.
# Otherwise specify as NULL or leave saveName and saveType arguments
# out of function calls.
fileNameRoot = "SmallSurgeon-POST-"
graphFileType = "eps"
#-------------------------------------------------------------------------------
# Generate the MCMC chain:
startTime = proc.time()
mcmcCoda = genMCMC( data=myData ,
zName="Fatalities", NName="Surgeries", sName="Surgeon", cName="Hospital",
numSavedSteps=11000 , saveName=fileNameRoot ,
thinSteps=20 )
pD = function(z,N,a,b) { exp( lbeta(z+a,N-z+b) - lbeta(a,b) ) }
omega1 = 0.25
omega2 = 0.75
kappa = 6
a1 = omega1*(kappa-2) + 1
b1 = (1-omega1)*(kappa-2) + 1
a2 = omega2*(kappa-2) + 1
b2 = (1-omega2)*(kappa-2) + 1
#Experiment Data
z= 7
N = 10
#From the equation in the book (10.6)
pm1 = pD(z,N,a1,b1)
pm2 = pD(z,N,a2,b2)
#Now we want to calculate the bayes factor
bf = pm1/pm2
# We then want to convert the bayes factor into the posterior probabilities.
p1=0.5
p2=1-p1
prior = (pm1/pm2)*(p1/p2)
p1pos = prior/(1.0+prior)
p2pos = 1.0-p1pos
prior
p1pos
p2pos
pD = function(z,N,a,b) { exp( lbeta(z+a,N-z+b) - lbeta(a,b) ) }
omega1 = 0.25
omega2 = 0.75
kappa = 202
a1 = omega1*(kappa-2) + 1
b1 = (1-omega1)*(kappa-2) + 1
a2 = omega2*(kappa-2) + 1
b2 = (1-omega2)*(kappa-2) + 1
#Experiment Data
z= 7
N = 10
#From the equation in the book (10.6)
pm1 = pD(z,N,a1,b1)
pm2 = pD(z,N,a2,b2)
#Now we want to calculate the bayes factor
bf = pm1/pm2
# We then want to convert the bayes factor into the posterior probabilities.
p1=0.5
p2=1-p1
prior = (pm1/pm2)*(p1/p2)
p1pos = prior/(1.0+prior)
p2pos = 1.0-p1pos
prior
p1pos
p2pos
?pbinom
pbviinom(3,45,0.6)
pbinom(3,45,1/3)
dbinom(1,45,0.6)
pbinom(3,45,1/6)
#-------------------------------------------------------------------------------
# Load The data
myData = read.csv("z6N8z2N7.csv")
winemag.data_first150k <- read.csv("~/Desktop/Final Project/winemag-data_first150k.csv")
winedata <- read.csv("~/Desktop/Final Project/winemag-data_first150k.csv")
unique(winedata$country)
View(winedata)
varietysummary <- winedata %>%
group_by(variety) %>%
summarise(no_rows = length(X))
install.packages("dplyr")
library(dplyr)
varietysummary <- winedata %>%
group_by(variety) %>%
summarise(no_rows = length(X))
View(varietysummary)
unique(winedata$region_2)
unique(winedata$country)
countrysummary <- winedata %>%
group_by(country) %>%
summarise(no_rows = length(X))
View(countrysummary)
countrylist <- c("US","Spain","Italy","France","Argentina","Portugal","Chile","Australia")
wineupdate <- filter(winedata, winedata$country %in% countrylist)
View(wineupdate)
unique(wineupdate$country)
varietysummary <- wineupdate %>%
group_by(variety) %>%
summarise(no_rows = length(X))
View(varietysummary)
varietysummary$variety[1:10]
View(varietysummary)
varietysummary <- wineupdate %>%
group_by(variety) %>%
summarise(no_rows = length(X)) %>%
varietysummary <- varietysummary[order(no_rows),]
varietysummary <- wineupdate %>%
group_by(variety) %>%
summarise(no_rows = length(X)) %>%
varietysummary <- varietysummary[,order(no_rows)]
varietysummary <- wineupdate %>%
group_by(variety) %>%
summarise(no_rows = length(X)) %>%
varietysummary <- varietysummary[order(varietysummary$no_rows),]
varietysummary <- varietysummary[order(varietysummary$no_rows),]
View(varietysummary)
varietysummary <- varietysummary[order(-varietysummary$no_rows),]
View(varietysummary)
setwd("~/Desktop/Wine-Project")
setwd("~/Desktop/Wine-Project")
winedata <- read.csv("winemag-data_first150k.csv")
varietyselection <- varietysummary$variety[1:8]
varietyselection
wineupdate <- filter(wineupdate, wineupdate$variety %in% varietyselection)
